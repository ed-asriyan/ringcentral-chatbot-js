{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RingCentral Chatbot Framework for Javascript The RingCentral Chatbot Framework for Javascript allows developers to easily create and deploy production-ready bots that work with RingCentral Team Messaging, a.k.a. \"Glip.\" The framework provides an out-of-box solution for many of the challenges all bot developers must overcome when creating stateful and smart bots to be used by the public. Get Started Features Bot token management . The bot is always authorized to access Glip resources, developers don\u2019t need to write any code to connection. Bot WebHook management . WebHooks are implemented in the framework so no code is needed to receive all kinds of events from Glip. Remove re-add bot . You can remove and re-add chatbots as you want, and the framework will take care of the setting up and cleaning up. Turn-key AWS Lambda Deployment . By using this framework, the chatbot you created can be easily deployed to AWS Lambda. Bot maintainence . Special bot commands allow you to easily update bot name and avatar and as the developer you don\u2019t need to write any code for it. Data Persistence . Data is saved in database. MySQL, Postgres and SQLite are supported.","title":"Home"},{"location":"#ringcentral-chatbot-framework-for-javascript","text":"The RingCentral Chatbot Framework for Javascript allows developers to easily create and deploy production-ready bots that work with RingCentral Team Messaging, a.k.a. \"Glip.\" The framework provides an out-of-box solution for many of the challenges all bot developers must overcome when creating stateful and smart bots to be used by the public. Get Started","title":"RingCentral Chatbot Framework for Javascript"},{"location":"#features","text":"Bot token management . The bot is always authorized to access Glip resources, developers don\u2019t need to write any code to connection. Bot WebHook management . WebHooks are implemented in the framework so no code is needed to receive all kinds of events from Glip. Remove re-add bot . You can remove and re-add chatbots as you want, and the framework will take care of the setting up and cleaning up. Turn-key AWS Lambda Deployment . By using this framework, the chatbot you created can be easily deployed to AWS Lambda. Bot maintainence . Special bot commands allow you to easily update bot name and avatar and as the developer you don\u2019t need to write any code for it. Data Persistence . Data is saved in database. MySQL, Postgres and SQLite are supported.","title":"Features"},{"location":"about/","text":"About the RingCentral Chatbot Framework for Javascript License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"About"},{"location":"about/#about-the-ringcentral-chatbot-framework-for-javascript","text":"","title":"About the RingCentral Chatbot Framework for Javascript"},{"location":"about/#license","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"samples/","text":"Built using the RingCentral Chatbot Framework... The following bots serve as simple examples for the kinds of bots that can be built using this framework. Each is open source and can serve as a reference implementation on how to build and deploys bots with different capabilities. Message Scheduler The Glip Crontab Chatbot allows Glip users to schedule future Glip notifications. Developers can view the source code on Github to learn how to handle messages from users and how to reply. RingCentral Assistant The RingCentral Chatbot Assistant allows Glip users to query/edit their RingCentral data and account via Glip. Developers can view the source code on Github to learn how to: Connect to and authorize users (via OAuth) on a third-party service. Respond to commands. Create a built-in help and support system. Google Drive Notifications The Google Drive Chatbot allows Glip users to monitor their Google Drive account for changes. When documents change, notifications are sent to Glip which the bot displays to users. Developers can view the source code on Github to learn how to: Connect to and authorize users (via OAuth) on a third-party service. Receive callbacks from a third-party service to generate notifications in Glip. Format notifications to include richly formated content.","title":"Sample Bots"},{"location":"samples/#built-using-the-ringcentral-chatbot-framework","text":"The following bots serve as simple examples for the kinds of bots that can be built using this framework. Each is open source and can serve as a reference implementation on how to build and deploys bots with different capabilities.","title":"Built using the RingCentral Chatbot Framework..."},{"location":"samples/#message-scheduler","text":"The Glip Crontab Chatbot allows Glip users to schedule future Glip notifications. Developers can view the source code on Github to learn how to handle messages from users and how to reply.","title":"Message Scheduler"},{"location":"samples/#ringcentral-assistant","text":"The RingCentral Chatbot Assistant allows Glip users to query/edit their RingCentral data and account via Glip. Developers can view the source code on Github to learn how to: Connect to and authorize users (via OAuth) on a third-party service. Respond to commands. Create a built-in help and support system.","title":"RingCentral Assistant"},{"location":"samples/#google-drive-notifications","text":"The Google Drive Chatbot allows Glip users to monitor their Google Drive account for changes. When documents change, notifications are sent to Glip which the bot displays to users. Developers can view the source code on Github to learn how to: Connect to and authorize users (via OAuth) on a third-party service. Receive callbacks from a third-party service to generate notifications in Glip. Format notifications to include richly formated content.","title":"Google Drive Notifications"},{"location":"developers/apps/","text":"Creating Your Bot App Every bot you create must be registered with RingCentral. That can be done manually (see instructions below), or can be created quickly using the button below. Create Bot App Manual Installation Instructions Login or create an account if you have not done so already. Go to Console/Apps and click 'Create App' button. Give your app a name and description, then click Next. On the second page of the create app wizard enter the following: Select 'Private' for Application Type. Select 'Server-only (No UI)' for Platform Type. On the third page of the create app wizard, select the following permissions: Glip Read Accounts Webhook Subscriptions","title":"Creating Your Bot App"},{"location":"developers/apps/#creating-your-bot-app","text":"Every bot you create must be registered with RingCentral. That can be done manually (see instructions below), or can be created quickly using the button below. Create Bot App","title":"Creating Your Bot App"},{"location":"developers/apps/#manual-installation-instructions","text":"Login or create an account if you have not done so already. Go to Console/Apps and click 'Create App' button. Give your app a name and description, then click Next. On the second page of the create app wizard enter the following: Select 'Private' for Application Type. Select 'Server-only (No UI)' for Platform Type. On the third page of the create app wizard, select the following permissions: Glip Read Accounts Webhook Subscriptions","title":"Manual Installation Instructions"},{"location":"developers/bots/","text":"Building Bots Sending Messages Every event handler receives as input a bot object. That object can then be used to send messages. For example: bot . sendMessage ( group . id , { text : Hello World }) In the above example the bot responds with simple text only. Bots can also respond with more formatted messages, which is achieved through the use of a message attachment. The RingCentral Developer Guide discussed message attachments in more detail. Event Handling A bot handler takes as input an \"event.\" Based on the type of the event, you can trigger different actions and behaviors. Here is a simple switch statement for handling different events: export const handle = async event = { console . log ( event . type , event ) switch ( event . type ) { case Message4Bot : break case BotJoinGroup : // bot user joined a new group break default : break } } Event Types Event Description Message4Bot Triggered when a message is posted to a team/conversation the bot belongs to. This event is NOT triggered for messages posted by the bot, to prevent the bot from responding to itself. BotRemoved Trigger when a bot is removed from a team/conversation. BotJoinGroup Trigger when a bot joins a team/conversation. Message4Bot When the Message4Bot event is triggered, the following parameters are passed to the handler: text - The text/message posted. This should be parsed by the handler to determine what action to perform. group - A group object representing the group/team/conversion the message was posted to. bot - A bot object representing the bot receiving the message. userId - The id of the user who sent the message.","title":"Building Bots"},{"location":"developers/bots/#building-bots","text":"","title":"Building Bots"},{"location":"developers/bots/#sending-messages","text":"Every event handler receives as input a bot object. That object can then be used to send messages. For example: bot . sendMessage ( group . id , { text : Hello World }) In the above example the bot responds with simple text only. Bots can also respond with more formatted messages, which is achieved through the use of a message attachment. The RingCentral Developer Guide discussed message attachments in more detail.","title":"Sending Messages"},{"location":"developers/bots/#event-handling","text":"A bot handler takes as input an \"event.\" Based on the type of the event, you can trigger different actions and behaviors. Here is a simple switch statement for handling different events: export const handle = async event = { console . log ( event . type , event ) switch ( event . type ) { case Message4Bot : break case BotJoinGroup : // bot user joined a new group break default : break } }","title":"Event Handling"},{"location":"developers/bots/#event-types","text":"Event Description Message4Bot Triggered when a message is posted to a team/conversation the bot belongs to. This event is NOT triggered for messages posted by the bot, to prevent the bot from responding to itself. BotRemoved Trigger when a bot is removed from a team/conversation. BotJoinGroup Trigger when a bot joins a team/conversation.","title":"Event Types"},{"location":"developers/bots/#message4bot","text":"When the Message4Bot event is triggered, the following parameters are passed to the handler: text - The text/message posted. This should be parsed by the handler to determine what action to perform. group - A group object representing the group/team/conversion the message was posted to. bot - A bot object representing the bot receiving the message. userId - The id of the user who sent the message.","title":"Message4Bot"},{"location":"developers/get-started/","text":"Getting Started To get started we recommend developing a bot on your local development machine or laptop. That can be done quickly and easily using the RingCentral Team Messaging Quick Start below. Read the Chatbot Quick Start Hello World: What a bot looks like In the Quick Start above you will learn how to create and define bot behavior in just 10 lines of code. Here is the source code needed to create a \"Ping Bot\" - a bot that responds with \"pong\" whenever it hears someone say \"ping.\" 1 2 3 4 5 6 7 8 9 10 const createApp = require ( ringcentral-chatbot/dist/apps ). default const handle = async event = { const { type , text , group , bot } = event if ( type === Message4Bot text === ping ) { await bot . sendMessage ( group . id , { text : pong }) } } const app = createApp ( handle ) app . listen ( process . env . RINGCENTRAL_CHATBOT_EXPRESS_PORT ) You can checkout other sample bots to see more complex behaviors.","title":"Getting Started"},{"location":"developers/get-started/#getting-started","text":"To get started we recommend developing a bot on your local development machine or laptop. That can be done quickly and easily using the RingCentral Team Messaging Quick Start below. Read the Chatbot Quick Start","title":"Getting Started"},{"location":"developers/get-started/#hello-world-what-a-bot-looks-like","text":"In the Quick Start above you will learn how to create and define bot behavior in just 10 lines of code. Here is the source code needed to create a \"Ping Bot\" - a bot that responds with \"pong\" whenever it hears someone say \"ping.\" 1 2 3 4 5 6 7 8 9 10 const createApp = require ( ringcentral-chatbot/dist/apps ). default const handle = async event = { const { type , text , group , bot } = event if ( type === Message4Bot text === ping ) { await bot . sendMessage ( group . id , { text : pong }) } } const app = createApp ( handle ) app . listen ( process . env . RINGCENTRAL_CHATBOT_EXPRESS_PORT ) You can checkout other sample bots to see more complex behaviors.","title":"Hello World: What a bot looks like"},{"location":"developers/lambda/","text":"Deploying a Bot to AWS Lambda This guide will take you through the process of deploying and hosting your bot on AWS Lambda. We recommend you do the following prior to reading this guide: Successful test your bot locally using the instructions in our Getting Started Guide . Familiarize yourself with our recommended project structure . When you are ready, Let's begin. Install dependencies To get started let's add some key dependencies to our project. yarn add ringcentral-chatbot serverless-http pg yarn add --dev serverless We installed pg because we choose to use PostgreSQL as our database in this example, but you are welcome to use any database you wish. We use serverless-http to use Express.js code in AWS Lambda so that we can reuse code between Express.js and AWS Lambda. We use serverless framework to help us deploy the project to AWS with ease. Code the Bot Nothing requires you to structure your project according to our recommendation . In the example below we encapsulate our entire bot in a single file lambda.js to more easily illustrate AWS deployment. Create and edit a file called lambda.js with the following content: const createApp = require ( ringcentral-chatbot/dist/apps ). default const { createAsyncProxy } = require ( ringcentral-chatbot/dist/lambda ) const serverlessHTTP = require ( serverless-http ) const handle = async event = { const { type , text , group , bot } = event if ( type === Message4Bot text === ping ) { await bot . sendMessage ( group . id , { text : pong }) } } const app = createApp ( handle ) module . exports . app = serverlessHTTP ( app ) module . exports . proxy = createAsyncProxy ( app ) Create and Setup Your Database If you have access to a MySQL or PostgreSQL database you are free to use that. If you do not, you can use AWS's RDS service to create one through the following steps: Login to the AWS Console and navigate to RDS. Create a PostgreSQL database. Configure the security group so that it is publicly accessible with username and password. Take a note of the database uri, database name, username and password, we will use them soon. Database Security Group Rules Be sure to configure your Security Group Rules so that your database is accessible from the outside. Your rules should look like this: Create .env.yml Create a file called .env.yml with the following properties (use this template to help): Property Description RINGCENTRAL_SERVER Use https://platform.dev.ringcentral.com for sandbox and https://platform.ringcentral.com for production RINGCENTRAL_CHATBOT_DATABASE_CONNECTION_URI please sepcify connection URI to a relational database. SQLite, MySQL and PostgreSQL are supported. We specify the AWS RDS we created above. RINGCENTRAL_CHATBOT_CLIENT_ID Retrieve from the RingCentral Developer Console. RINGCENTRAL_CHATBOT_CLIENT_SECRET Retrieve from the RingCentral Developer Console. RINGCENTRAL_CHATBOT_SERVER We don't know until we deploy the project to AWS, let's specify a dummy one for now: https://xxxxxx.execute-api.us-east-1.amazonaws.com/prod RINGCENTRAL_CHATBOT_ADMIN_USERNAME An admin username of your choice. RINGCENTRAL_CHATBOT_ADMIN_PASSWORD An admin password of your choice. Create serverless.yml Create serverless.yml with following content: service : name : demo-ping-chatbot provider : stage : ${opt:stage, prod } name : aws runtime : nodejs8.10 region : us-east-1 memorySize : 256 environment : ${file(./.env.yml)} iamRoleStatements : - Effect : Allow Action : - lambda:InvokeFunction Resource : * package : exclude : - ./** - !lambda.js - !node_modules/** excludeDevDependencies : true functions : app : handler : lambda.app timeout : 300 proxy : handler : lambda.proxy events : - http : ANY {proxy+} Get a Lambda URL To obtain the public URL of your new chat bot, you must deploy to AWS. This URL is essential as it will be used to tell RingCentral where to post webhooks and notifications when users install and interact with your bot. npx sls deploy Update .env.yml Once the project is successfully deployed, a Lambda URL will be provisioned to you. Now, edit the .env.yml file and set RINGCENTRAL_CHATBOT_SERVER to this URL. It should be in the form of: https://xxxxxx.execute-api.yyyy.amazonaws.com/prod Redeploy to AWS We must redeploy the bot after we edit env.yml : npx sls deploy Set the \"OAuth Redirect URI\" Login to https://developer.ringcentral.com, navigate to your bot app, and open the \"Settings\" tab. Then set \"OAuth Redirect URI\" to your bot's OAuth endpoint. The URL is your Lambda URL plus \"/prod/bot/oauth\". For example: https://xxxxxx.execute-api.yyyyy.amazonaws.com/prod/bot/oauth Initialize the Database With your bot setup and deployed, we need to initialize the database by creating the database tables needed to manage the bot's state, and persist the many auth tokens, and subscriptions needed to keep your bot up and running. curl -X PUT -u admin:password https:// chatbot-server /prod/admin/setup-database The access credentials ( -u admin:password ) are defined in the env.yml file we created above. Install and Test the Bot Once all of the above is complete, open your Bot in the RingCentral Developer Console. Click \"Bot\" in the left-hand menu. Set your bot name, then click the button \"Add to Glip.\" Then login to the Glip Sandbox to test. Troubleshooting Our community has shared some of these troubleshooting experiences, feel free to add your own. AWS Lambda connects AWS RDS issue If you create an RDS manually and let it create a new security group for you. By default, the security group only allows inbound traffic from your current laptop's public IP address AWS Lambda by default cannot access the newly created AWS RDS We need to update security group to allow inbound traffic from 0.0.0.0/0 AWS Lambda and await issue AWS Lambda is stateless and it won't keep a background task running So if your code is async, DO remember to use await . Otherwise that code will not be executed before Lambda invocation terminates I forgot to await , a weird phenomenon was: whenever I issued a command, I always got reply of previous command AWS Lambda global code dead-lock issue Do NOT invoke lambda functions in global code outside of handlers I tried once and it seemed to case dead-lock. Lots of requests which causes 429 error and database connection exhausted In global code I did axio.put('https:// bot-server /admin/maintain') and it caused dead-lock","title":"Deploying to AWS Lambda"},{"location":"developers/lambda/#deploying-a-bot-to-aws-lambda","text":"This guide will take you through the process of deploying and hosting your bot on AWS Lambda. We recommend you do the following prior to reading this guide: Successful test your bot locally using the instructions in our Getting Started Guide . Familiarize yourself with our recommended project structure . When you are ready, Let's begin.","title":"Deploying a Bot to AWS Lambda"},{"location":"developers/lambda/#install-dependencies","text":"To get started let's add some key dependencies to our project. yarn add ringcentral-chatbot serverless-http pg yarn add --dev serverless We installed pg because we choose to use PostgreSQL as our database in this example, but you are welcome to use any database you wish. We use serverless-http to use Express.js code in AWS Lambda so that we can reuse code between Express.js and AWS Lambda. We use serverless framework to help us deploy the project to AWS with ease.","title":"Install dependencies"},{"location":"developers/lambda/#code-the-bot","text":"Nothing requires you to structure your project according to our recommendation . In the example below we encapsulate our entire bot in a single file lambda.js to more easily illustrate AWS deployment. Create and edit a file called lambda.js with the following content: const createApp = require ( ringcentral-chatbot/dist/apps ). default const { createAsyncProxy } = require ( ringcentral-chatbot/dist/lambda ) const serverlessHTTP = require ( serverless-http ) const handle = async event = { const { type , text , group , bot } = event if ( type === Message4Bot text === ping ) { await bot . sendMessage ( group . id , { text : pong }) } } const app = createApp ( handle ) module . exports . app = serverlessHTTP ( app ) module . exports . proxy = createAsyncProxy ( app )","title":"Code the Bot"},{"location":"developers/lambda/#create-and-setup-your-database","text":"If you have access to a MySQL or PostgreSQL database you are free to use that. If you do not, you can use AWS's RDS service to create one through the following steps: Login to the AWS Console and navigate to RDS. Create a PostgreSQL database. Configure the security group so that it is publicly accessible with username and password. Take a note of the database uri, database name, username and password, we will use them soon. Database Security Group Rules Be sure to configure your Security Group Rules so that your database is accessible from the outside. Your rules should look like this:","title":"Create and Setup Your Database"},{"location":"developers/lambda/#create-envyml","text":"Create a file called .env.yml with the following properties (use this template to help): Property Description RINGCENTRAL_SERVER Use https://platform.dev.ringcentral.com for sandbox and https://platform.ringcentral.com for production RINGCENTRAL_CHATBOT_DATABASE_CONNECTION_URI please sepcify connection URI to a relational database. SQLite, MySQL and PostgreSQL are supported. We specify the AWS RDS we created above. RINGCENTRAL_CHATBOT_CLIENT_ID Retrieve from the RingCentral Developer Console. RINGCENTRAL_CHATBOT_CLIENT_SECRET Retrieve from the RingCentral Developer Console. RINGCENTRAL_CHATBOT_SERVER We don't know until we deploy the project to AWS, let's specify a dummy one for now: https://xxxxxx.execute-api.us-east-1.amazonaws.com/prod RINGCENTRAL_CHATBOT_ADMIN_USERNAME An admin username of your choice. RINGCENTRAL_CHATBOT_ADMIN_PASSWORD An admin password of your choice.","title":"Create .env.yml"},{"location":"developers/lambda/#create-serverlessyml","text":"Create serverless.yml with following content: service : name : demo-ping-chatbot provider : stage : ${opt:stage, prod } name : aws runtime : nodejs8.10 region : us-east-1 memorySize : 256 environment : ${file(./.env.yml)} iamRoleStatements : - Effect : Allow Action : - lambda:InvokeFunction Resource : * package : exclude : - ./** - !lambda.js - !node_modules/** excludeDevDependencies : true functions : app : handler : lambda.app timeout : 300 proxy : handler : lambda.proxy events : - http : ANY {proxy+}","title":"Create serverless.yml"},{"location":"developers/lambda/#get-a-lambda-url","text":"To obtain the public URL of your new chat bot, you must deploy to AWS. This URL is essential as it will be used to tell RingCentral where to post webhooks and notifications when users install and interact with your bot. npx sls deploy","title":"Get a Lambda URL"},{"location":"developers/lambda/#update-envyml","text":"Once the project is successfully deployed, a Lambda URL will be provisioned to you. Now, edit the .env.yml file and set RINGCENTRAL_CHATBOT_SERVER to this URL. It should be in the form of: https://xxxxxx.execute-api.yyyy.amazonaws.com/prod","title":"Update .env.yml"},{"location":"developers/lambda/#redeploy-to-aws","text":"We must redeploy the bot after we edit env.yml : npx sls deploy","title":"Redeploy to AWS"},{"location":"developers/lambda/#set-the-oauth-redirect-uri","text":"Login to https://developer.ringcentral.com, navigate to your bot app, and open the \"Settings\" tab. Then set \"OAuth Redirect URI\" to your bot's OAuth endpoint. The URL is your Lambda URL plus \"/prod/bot/oauth\". For example: https://xxxxxx.execute-api.yyyyy.amazonaws.com/prod/bot/oauth","title":"Set the \"OAuth Redirect URI\""},{"location":"developers/lambda/#initialize-the-database","text":"With your bot setup and deployed, we need to initialize the database by creating the database tables needed to manage the bot's state, and persist the many auth tokens, and subscriptions needed to keep your bot up and running. curl -X PUT -u admin:password https:// chatbot-server /prod/admin/setup-database The access credentials ( -u admin:password ) are defined in the env.yml file we created above.","title":"Initialize the Database"},{"location":"developers/lambda/#install-and-test-the-bot","text":"Once all of the above is complete, open your Bot in the RingCentral Developer Console. Click \"Bot\" in the left-hand menu. Set your bot name, then click the button \"Add to Glip.\" Then login to the Glip Sandbox to test.","title":"Install and Test the Bot"},{"location":"developers/lambda/#troubleshooting","text":"Our community has shared some of these troubleshooting experiences, feel free to add your own. AWS Lambda connects AWS RDS issue If you create an RDS manually and let it create a new security group for you. By default, the security group only allows inbound traffic from your current laptop's public IP address AWS Lambda by default cannot access the newly created AWS RDS We need to update security group to allow inbound traffic from 0.0.0.0/0 AWS Lambda and await issue AWS Lambda is stateless and it won't keep a background task running So if your code is async, DO remember to use await . Otherwise that code will not be executed before Lambda invocation terminates I forgot to await , a weird phenomenon was: whenever I issued a command, I always got reply of previous command AWS Lambda global code dead-lock issue Do NOT invoke lambda functions in global code outside of handlers I tried once and it seemed to case dead-lock. Lots of requests which causes 429 error and database connection exhausted In global code I did axio.put('https:// bot-server /admin/maintain') and it caused dead-lock","title":"Troubleshooting"},{"location":"developers/maintain/","text":"Maintaining Supporting Bots The Bot Framework exposes via an admin interface a number of functions to help bot developers and operators support and maintain their bot. Bot Maintenance This function is useful in the following cases: Reset Webhooks Subscriptions - Webhook subscriptions expire automatically on RingCentral. RingCentral may also blacklist your Webhook handler if it responds with too many errors. This method will resubscribe your app to webhook notifications relevant to your bot. Clean-up Databases - This will clean up any orphaned data in your datase. Invoke this function as follows: curl -X PUT -u admin:password https:// bot-server /admin/maintain Recommendation It is recommended that you create a cron job to run this command daily. Bot Diagnostics If your bot begins to behave strangely, or becomes unresponsive, invoke this command to get some insight into what is happening in the framework. curl -X GET -u admin:password https:// bot-server /admin/diagnostic Hidden commands The framework automattically adds support for the following commands to perform special actions that make maintaining your bot easier: __rename__ newName : rename bot to newName __setAvatar__ with an attached image file: set bot avatar to the attached image","title":"Bot Maintenance"},{"location":"developers/maintain/#maintaining-supporting-bots","text":"The Bot Framework exposes via an admin interface a number of functions to help bot developers and operators support and maintain their bot.","title":"Maintaining &amp; Supporting Bots"},{"location":"developers/maintain/#bot-maintenance","text":"This function is useful in the following cases: Reset Webhooks Subscriptions - Webhook subscriptions expire automatically on RingCentral. RingCentral may also blacklist your Webhook handler if it responds with too many errors. This method will resubscribe your app to webhook notifications relevant to your bot. Clean-up Databases - This will clean up any orphaned data in your datase. Invoke this function as follows: curl -X PUT -u admin:password https:// bot-server /admin/maintain Recommendation It is recommended that you create a cron job to run this command daily.","title":"Bot Maintenance"},{"location":"developers/maintain/#bot-diagnostics","text":"If your bot begins to behave strangely, or becomes unresponsive, invoke this command to get some insight into what is happening in the framework. curl -X GET -u admin:password https:// bot-server /admin/diagnostic","title":"Bot Diagnostics"},{"location":"developers/maintain/#hidden-commands","text":"The framework automattically adds support for the following commands to perform special actions that make maintaining your bot easier: __rename__ newName : rename bot to newName __setAvatar__ with an attached image file: set bot avatar to the attached image","title":"Hidden commands"},{"location":"developers/skills/","text":"Developing Custom Bot Skills A \"skill\" is a mechanism to reuse chatbot code that can be shared across multiple bots. A skill is just a plain JavaScript object with two optional properties: handle - a function which will be invoked when there is an event app - an express app Example Skills Ping Skill The following shows the structure of a \"Ping Skill\" which will reply \"pong\" to anyone who types \"ping.\" const handle = async event = { const { type , text , group , bot } = event if ( type === Message4Bot text === ping ) { await bot . sendMessage ( group . id , { text : pong }) return true // event handled } return false // event not handled } const app = express () app . get ( /hello , async ( req , res ) = { res . send ( world ) }) const pingSkill = { handle , app } In addition to containing the simple messaging logic, the above skill exposes a new page at uri path '/hello', which, when visited, will display \"world\". Install the Skill import createApp from ringcentral-chatbot/dist/apps const app = createApp ( undefined , [ pingSkill ]) In the sample above app above is a chatbot app, and it has all the behaviors of pingSkill . \"catch-all\" skill This following \"Catch All\" skill defines default behavior for your bot for all commands it does not recognize. const handle = async ( event , handled ) = { if ( ! handled ) { console . log ( `This is an unhandled event` ) } else { // event has been handled by other skills already } } const catchAllSkill = { handle } Catch-all skill should be the last in the skills list Real projects Ping Skill Ping Skill The Bot which uses the Ping Skill Google Drive Skill Google Drive Skill Google Drive Chatbot","title":"Developing \"Skills\""},{"location":"developers/skills/#developing-custom-bot-skills","text":"A \"skill\" is a mechanism to reuse chatbot code that can be shared across multiple bots. A skill is just a plain JavaScript object with two optional properties: handle - a function which will be invoked when there is an event app - an express app","title":"Developing Custom Bot Skills"},{"location":"developers/skills/#example-skills","text":"","title":"Example Skills"},{"location":"developers/skills/#ping-skill","text":"The following shows the structure of a \"Ping Skill\" which will reply \"pong\" to anyone who types \"ping.\" const handle = async event = { const { type , text , group , bot } = event if ( type === Message4Bot text === ping ) { await bot . sendMessage ( group . id , { text : pong }) return true // event handled } return false // event not handled } const app = express () app . get ( /hello , async ( req , res ) = { res . send ( world ) }) const pingSkill = { handle , app } In addition to containing the simple messaging logic, the above skill exposes a new page at uri path '/hello', which, when visited, will display \"world\".","title":"Ping Skill"},{"location":"developers/skills/#install-the-skill","text":"import createApp from ringcentral-chatbot/dist/apps const app = createApp ( undefined , [ pingSkill ]) In the sample above app above is a chatbot app, and it has all the behaviors of pingSkill .","title":"Install the Skill"},{"location":"developers/skills/#catch-all-skill","text":"This following \"Catch All\" skill defines default behavior for your bot for all commands it does not recognize. const handle = async ( event , handled ) = { if ( ! handled ) { console . log ( `This is an unhandled event` ) } else { // event has been handled by other skills already } } const catchAllSkill = { handle } Catch-all skill should be the last in the skills list","title":"\"catch-all\" skill"},{"location":"developers/skills/#real-projects","text":"","title":"Real projects"},{"location":"developers/skills/#ping-skill_1","text":"Ping Skill The Bot which uses the Ping Skill","title":"Ping Skill"},{"location":"developers/skills/#google-drive-skill","text":"Google Drive Skill Google Drive Chatbot","title":"Google Drive Skill"},{"location":"developers/structure/","text":"Structuring Your Bot Project We recommend structuring your project to encapsulate your bot's logic and behavior independently from the hosting container, e.g. Express and Lambda. A project might therefore have this structure: bot.js - This file contains just your bot logic, the messages it sends, the events it listens for, etc. app.js - This file the logic for handling web requests, such as processing webhooks from third parties, and any other web content that could be served. express.js - This file wraps app.js to host in an Express container for hosting on your laptop or your own infrastructure. lambda.js - This file wraps app.js to host on AWS Lambda. bot.js import { Service } from ringcentral-chatbot/dist/models export const handle = async event = { console . log ( event . type , event ) switch ( event . type ) { case Message4Bot : // bot logic break default : break } } app.js import createApp from ringcentral-chatbot/dist/apps import { Service , Bot } from ringcentral-chatbot/dist/models import { handle } from ./bot const app = createApp ( handle ) // app logic, for example... // app.get( /webhook-handler , async (req, res) = { }) export default app express.js import axios from axios import app from ./bot let PORT = process . env . RINGCENTRAL_CHATBOT_SERVER if ( process . env . PORT ) { PORT = process . env . PORT } app . listen ( PORT , () = { console . log ( `Server is running on port ${ PORT } ` ) }) lambda.js const serverlessHTTP = require ( serverless-http ) const { createAsyncProxy } = require ( ringcentral-chatbot/dist/lambda ) const createApp = require ( ringcentral-chatbot/dist/apps ). default const app = require ( ./app ). default module . exports . app = serverlessHTTP ( app ) module . exports . proxy = createAsyncProxy ( app )","title":"Project Structure"},{"location":"developers/structure/#structuring-your-bot-project","text":"We recommend structuring your project to encapsulate your bot's logic and behavior independently from the hosting container, e.g. Express and Lambda. A project might therefore have this structure: bot.js - This file contains just your bot logic, the messages it sends, the events it listens for, etc. app.js - This file the logic for handling web requests, such as processing webhooks from third parties, and any other web content that could be served. express.js - This file wraps app.js to host in an Express container for hosting on your laptop or your own infrastructure. lambda.js - This file wraps app.js to host on AWS Lambda.","title":"Structuring Your Bot Project"},{"location":"developers/structure/#botjs","text":"import { Service } from ringcentral-chatbot/dist/models export const handle = async event = { console . log ( event . type , event ) switch ( event . type ) { case Message4Bot : // bot logic break default : break } }","title":"bot.js"},{"location":"developers/structure/#appjs","text":"import createApp from ringcentral-chatbot/dist/apps import { Service , Bot } from ringcentral-chatbot/dist/models import { handle } from ./bot const app = createApp ( handle ) // app logic, for example... // app.get( /webhook-handler , async (req, res) = { }) export default app","title":"app.js"},{"location":"developers/structure/#expressjs","text":"import axios from axios import app from ./bot let PORT = process . env . RINGCENTRAL_CHATBOT_SERVER if ( process . env . PORT ) { PORT = process . env . PORT } app . listen ( PORT , () = { console . log ( `Server is running on port ${ PORT } ` ) })","title":"express.js"},{"location":"developers/structure/#lambdajs","text":"const serverlessHTTP = require ( serverless-http ) const { createAsyncProxy } = require ( ringcentral-chatbot/dist/lambda ) const createApp = require ( ringcentral-chatbot/dist/apps ). default const app = require ( ./app ). default module . exports . app = serverlessHTTP ( app ) module . exports . proxy = createAsyncProxy ( app )","title":"lambda.js"}]}